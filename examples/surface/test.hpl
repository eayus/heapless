let id : [a :: *3]. a -> a =
    \x => x;

let n : Int -> Int = id (\x => x);

let const : [a :: *3, b :: *3]. a -> b -> a =
    (\x y => x);

let composeN : [a :: *1]. Int -> (a -> a) -> a -> a =
    \m f =>
        let rec go : Int -> a -> a =
            \n x => if n >= 0
                then go (n - 1) (f x)
                else x;
        go m
    ;

let m : Int = if False then 3 else 4;

data Maybe :=
  | Just (Int -> Int)
  | Nothing;

let foo : Maybe = Nothing;

class Num (a :: *1) {
    add : a -> a -> a;
    sub : a -> a -> a;
}

inst Num Int {
    add = \x y => x + y;
    sub = \x y => x - y;
}

let double : [a :: *1]. {Num a} => a -> a =
    \x => add x x;

let foo : Int = add 3 4;

let name : String = "Ellis";

data Unit =
  | It;

class Monad (m :: *1 -> *2) {
    pure : [a :: *1]. a -> m a;
    bind : [a :: *1, b :: *1]. m a -> (a -> m b) -> m b;
}

let void : [m :: *1 -> *2]. {Monad m} => m Unit =
    pure It;


inst Monad IO {
    pure = ioPure;
    bind = ioBind;
}

let main : IO Unit = pure It;

// Intererestingly we cannot define 'join' if monads have kind "*1 -> *2", as the type "m (m a)" is invalid.
// It begs the fundamental question - why is this disallowed? As long as the definition is non-recursive, perhaps kind checking should be disabled entirely?
// Perhaps the type of a monad is more like "forall i. *i -> *(suc i)"

// let join : [m :: *1 -> *2, a :: *1]. {Monad m} => m (m a) -> m a =
//     \x => bind x (\y => y);

// Implement FizzBuzz

/*
let main : IO () = do {
    n : Int <- read
    m : Int <- read
};
*/