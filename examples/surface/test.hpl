let id : [a :: *3]. a -> a =
    \x => x;

let n : Int -> Int = id (\x => x);

let const : [a :: *3, b :: *3]. a -> b -> a =
    (\x y => x);

let composeN : [a :: *1]. Int -> (a -> a) -> a -> a =
    \m f =>
        let rec go : Int -> a -> a =
            \n x => if n >= 0
                then go (n - 1) (f x)
                else x;
        go m
    ;

let m : Int = if False then 3 else 4;

data Maybe :=
  | Just (Int -> Int)
  | Nothing;

let foo : Maybe = Nothing;

class Num (a :: *1) {
    add : a -> a -> a;
    sub : a -> a -> a;
}

inst Num Int {
    add = \x y => x + y;
    sub = \x y => x - y;
}

let double : [a :: *1]. {Num a} => a -> a =
    \x => add x x;

let foo : Int = add 3 4;

let name : String = "Ellis";

data Unit =
  | It;

class Monad (m :: *1 -> *2) {
    pure : [a :: *1]. a -> m a;
    bind : [a :: *1, b :: *1]. m a -> (a -> m b) -> m b;
}

let void : [m :: *1 -> *2]. {Monad m} => m Unit =
    pure It;


inst Monad IO {
    pure = ioPure;
    bind = ioBind;
}

let main : IO Unit = do {
    x <- pure It;
    pure x
};

// Join only works on monads which are *1 -> *1, as otherwise m (m a) is invalid.
let join : [m :: *1 -> *1, a :: *1]. {Monad m} => m (m a) -> m a = \x => do {
    y <- x;
    y
};

// Implement FizzBuzz

/*
let main : IO () = do {
    n : Int <- read
    m : Int <- read
};
*/