λ w0.

    type Monad :: (Type -> Type) -> Type = λ M. (
        // pure
        ∀ A :: Type. A -> M A,

        // bind
        ∀ A :: Type. ∀ B :: Type. M A -> (A -> M B) -> M B
    );

    let replicateM :
        ∀ M :: Type -> Type. ∀ A :: Type.
        O1 (M Unit) -> Monad M -> Int -> M A -> M Unit =

        Λ M. Λ A.
        λ o1. λ monad. λ n. λ f.
            let (pure, bind) : Monad M = monad;
            let rec go : Int -> M Unit proof #funcO1[#primO0[], o1] =
                λ m. if m == 0
                    then pure @Unit unit
                    else bind @A @Unit f (λ a. go (m - 1));
            go n;

    type IO :: Type -> Type = λ A. World -o (1 World, A);

    let pure : ∀ A :: Type. A -> IO A =
        Λ A. λx. λw. (w, x);

    let bind : ∀ A :: Type. ∀ B :: Type. IO A -> (A -> IO B) -> IO B =
        Λ A. Λ B. λx. λf. λw2.
            let 1 (w1, a) = x w2;
            f a w1;
    
    let run : IO Unit -> (World -o World) =
        λf. λw. let 1 (w1, u) = f w; w1;

    let printInt : Int -> IO Unit =
        λn. λw. (#printInt[n, w], unit);

    let ioMonad : Monad IO = (pure, bind);

    let ioUnitO1 : O1 (IO Unit) = #funcO1[#primO0[], #liftO0[#prodO0[#primO0[], #primO0[]]]];

    let main : IO Unit =
        replicateM @IO @Unit ioUnitO1 ioMonad 10 (printInt 2);

    run main w0
